package com.team1816.season.subsystems;

public class DistanceManager {

    // State
    private final Entry[] buckets;

    // Constants
    public DistanceManager() {
        buckets = distance_buckets;
    }

    static class Entry {

        public final double distance;
        public final double spindexerOutput;
        public final double elevatorOutput;
        public final double shooterVelocity;
        public final double hoodRetracted;

        Entry(
            double distance,
            double spindexerOutput,
            double elevatorOutput,
            double shooterVelocity,
            double hoodRetracted
        ) {
            this.distance = distance;
            this.spindexerOutput = spindexerOutput;
            this.elevatorOutput = elevatorOutput;
            this.shooterVelocity = shooterVelocity;
            this.hoodRetracted = hoodRetracted;
        }

        Entry() {
            this(0, 0, 0, 0, 0);
        }
    }

    private final Entry[] distance_buckets = new Entry[] {
        new Entry(133, .85, 1, 10700, 0),
        new Entry(250, 1.7, 1, 10100, 0),
        new Entry(280, 1.6, 1, 10300, 0),
        new Entry(340, 1.5, 1, 10700, 0),
    };

    private double getSpindexerOutput(double distance) {
//        if(distance < 110){
//            return 0;
//        }
        return .38;
    }

    private double getElevatorOutput(double distance) { // TODO lots of hacks here - generate real outputs with hood in future
//        if(distance < 100){
//            return 0.5;
//        }
//        for (Entry bucket : buckets) {
//            if (distance <= bucket.distance) {
//                return bucket.elevatorOutput;
//            }
//        }
        return .5;
    }

    private double getShooterVelocity(double distance) {
        if(distance < 90){
            return Shooter.NEAR_VELOCITY;
        }
        int x = 0;
        // cubic spline for shooter speed developed through repeated testing
        if(distance < 97) {
            return 0; //-0.05460540718377771* distance ^3+15.890173490479313* distance ^2+-1475.3520825167316* distance ^1+50635.39042284306* distance ^0;
        } else if(distance < 105) {
            return -0.017093 * Math.pow(distance, 3) + 4.6524 * Math.pow(distance, 2) - 375.15 * distance + 20465;
        } else if(distance < 115) {
            return 0.025874 * Math.pow(distance, 3) - 9.1400 * Math.pow(distance, 2) + 1100.6 * distance - 32171;
        } else if(distance < 125) {
            return -0.0040377 * Math.pow(distance, 3) + 1.8075 * Math.pow(distance, 2) - 234.96 * distance + 22143;
        } else if(distance < 135){
            return 0.11195 * Math.pow(distance, 3) - 44.822 * Math.pow(distance, 2) + 6013.3 * distance - 256950;
        } else if(distance < 140){
            return -0.19873 * Math.pow(distance, 3) + 89.442 * Math.pow(distance, 2) - 13328.0 * distance + 671810;
        } else if(distance < 145){
            return 0.025159 * Math.pow(distance, 3) - 13.993 * Math.pow(distance, 2) + 2601.0 * distance - 145880;
        } else if(distance < 155){
            return 0.039889 * Math.pow(distance, 3) - 21.240 * Math.pow(distance, 2) + 3789.5 * distance - 210850;
        } else if(distance < 165){
            return 0.025159 * Math.pow(distance, 3) - 13.993 * Math.pow(distance, 2) + 2601.0 * distance - 145880;
        } else if(distance < 175){
            return 0.039889 * Math.pow(distance, 3) - 21.240 * Math.pow(distance, 2) + 3789.5 * distance - 210850;
        } else if(distance < 190){
            return 0.025159 * Math.pow(distance, 3) - 13.993 * Math.pow(distance, 2) + 2601.0 * distance - 145880;
        } else if(distance < 200){
            return 0.039889 * Math.pow(distance, 3) - 21.240 * Math.pow(distance, 2) + 3789.5 * distance - 210850;
        } else if(distance < 210){
            return 0.025159 * Math.pow(distance, 3) - 13.993 * Math.pow(distance, 2) + 2601.0 * distance - 145880;
        } else {
            return -0.012978 * Math.pow(distance, 3) + 7.9424 * Math.pow(distance, 2) - 1580.0 * distance + 118480;
        }
//        return (distance * 51.8) + 6600; // linear equation generated by testing @ MURA - 52-5500
    }

    private double getHoodRetracted(double distance) {
        if(distance < 90){
            return 0;
        }
        return 1;
    }

    public double getOutput(double distance, SUBSYSTEM subsystem) {
        switch (subsystem) {
            case SPINDEXER:
                return getSpindexerOutput(distance);
            case ELEVATOR:
                return getElevatorOutput(distance);
            case SHOOTER:
                return getShooterVelocity(distance);
            case HOOD:
                return getHoodRetracted(distance);
        }
        System.out.println("not a SUBSYSTEM!");
        return 0;
    }

    public enum SUBSYSTEM {
        SPINDEXER,
        ELEVATOR,
        SHOOTER,
        HOOD,
    }
}
